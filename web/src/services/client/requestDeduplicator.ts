/**
 * Request Deduplicator
 *
 * Prevents duplicate concurrent requests by tracking in-flight promises.
 * When multiple identical requests are made concurrently, they share
 * the same promise instead of making separate HTTP requests.
 *
 * This is particularly useful for:
 * - Preventing race conditions in rapid UI updates
 * - Reducing unnecessary network load
 * - Improving application responsiveness
 */

/**
 * Deduplication statistics
 */
export interface DeduplicationStats {
  total: number;
  deduplicated: number;
  active: number;
}

/**
 * Request deduplicator implementation
 */
class RequestDeduplicatorImpl {
  private pendingRequests: Map<string, Promise<unknown>> = new Map();
  private _totalRequests: number = 0;
  private _deduplicatedRequests: number = 0;

  /**
   * Generate a deduplication key from method, URL, and params
   *
   * The key is generated by combining method, URL, and sorted params
   * to ensure consistent keys regardless of param order.
   */
  deduplicateKey(
    method: string,
    url: string,
    params?: Record<string, unknown> | null
  ): string {
    let key = `${method}-${url}`;

    if (params && Object.keys(params).length > 0) {
      const sortedParams = Object.keys(params).sort();
      const paramString = sortedParams
        .map((k) => `${k}=${JSON.stringify(params[k])}`)
        .join('&');
      key += `?${paramString}`;
    }

    return key;
  }

  /**
   * Track a promise by key
   */
  track(key: string, promise: Promise<unknown>): void {
    this.pendingRequests.set(key, promise);
  }

  /**
   * Get a tracked promise by key
   */
  getPromise(key: string): Promise<unknown> | undefined {
    return this.pendingRequests.get(key);
  }

  /**
   * Deduplicate a request
   *
   * If a request with the same key is already in flight, return its promise.
   * Otherwise, execute the provided function and track its promise.
   *
   * The promise is automatically removed from tracking when it settles.
   */
  async deduplicate<T>(
    key: string,
    executor: () => Promise<T>
  ): Promise<T> {
    this._totalRequests++;

    // Check if there's an in-flight request
    const existingPromise = this.pendingRequests.get(key);
    if (existingPromise) {
      this._deduplicatedRequests++;
      return existingPromise as Promise<T>;
    }

    // Create new request
    const promise = executor();

    // Track the promise
    this.pendingRequests.set(key, promise);

    // Clean up when promise settles (regardless of outcome)
    const cleanup = () => {
      this.pendingRequests.delete(key);
    };

    promise.then(cleanup).catch(cleanup);

    return promise;
  }

  /**
   * Get deduplication statistics
   */
  getStats(): DeduplicationStats {
    return {
      total: this._totalRequests,
      deduplicated: this._deduplicatedRequests,
      active: this.pendingRequests.size,
    };
  }

  /**
   * Clear all tracked promises and reset statistics
   */
  clear(): void {
    this.pendingRequests.clear();
    this._totalRequests = 0;
    this._deduplicatedRequests = 0;
  }

  /**
   * Delete a specific tracked promise
   */
  delete(key: string): void {
    this.pendingRequests.delete(key);
  }

  /**
   * Get all tracked keys
   */
  keys(): string[] {
    return Array.from(this.pendingRequests.keys());
  }

  /**
   * Check if a key is currently tracked
   */
  has(key: string): boolean {
    return this.pendingRequests.has(key);
  }
}

// Export singleton instance
export const requestDeduplicator = new RequestDeduplicatorImpl();

// Export type for convenience
export type { DeduplicationStats };
